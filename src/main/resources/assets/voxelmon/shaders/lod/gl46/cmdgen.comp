#version 460
#extension GL_ARB_gpu_shader_int64 : enable

layout(local_size_x = 128, local_size_y = 1, local_size_x = 1) in;

#import <voxelmon:lod/gl46/quad_format.glsl>
#import <voxelmon:lod/gl46/bindings.glsl>
#import <voxelmon:lod/gl46/frustum.glsl>
#import <voxelmon:lod/gl46/section.glsl>

//https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GL_EXT_shader_16bit_storage.txt
// adds support for uint8_t which can use for compact visibility buffer



/*
    uint  count;
    uint  instanceCount;
    uint  firstIndex;
    int  baseVertex;
    uint  baseInstance;
    */

uint encodeLocalLodPos(uint detail, ivec3 pos) {
    uvec3 detla = (pos - (baseSectionPos >> detail))&((1<<9)-1);
    return (detail<<29)|(detla.x<<20)|(detla.y<<11)|(detla.z<<2);
}

void main() {
    if (gl_GlobalInvocationID.x >= sectionCount) {
        return;
    }
    SectionMeta meta = sectionData[gl_GlobalInvocationID.x];
    uint detail = extractDetail(meta);
    ivec3 ipos = extractPosition(meta);

    //TODO: fixme; i dont think this is correct
    vec3 cornerPos = vec3(((ipos<<detail)-baseSectionPos)<<5)-cameraSubPos;


    bool shouldRender = testFrustum(frustum, cornerPos, cornerPos+vec3(1<<(detail+5)));

    //This prevents overflow of the relative position encoder
    if (shouldRender) {
        shouldRender = !any(lessThan(ivec3(254), abs(ipos-(baseSectionPos>>detail))));
    }

    if (shouldRender) {
        DrawCommand cmd;
        cmd.count = extractQuadCount(meta) * 6;
        cmd.instanceCount = 1;
        cmd.firstIndex = 0;
        cmd.baseVertex = int(extractQuadStart(meta))<<2;
        cmd.baseInstance = encodeLocalLodPos(detail, ipos);
        cmdBuffer[gl_GlobalInvocationID.x] = cmd;
    } else {
        DrawCommand cmd;
        cmd.count = 0;
        cmd.instanceCount = 0;
        cmd.firstIndex = 0;
        cmd.baseVertex = 0;
        cmd.baseInstance = 0;
        cmdBuffer[gl_GlobalInvocationID.x] = cmd;
    }
}