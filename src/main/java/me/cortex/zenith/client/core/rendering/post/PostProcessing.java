package me.cortex.zenith.client.core.rendering.post;

import me.cortex.zenith.client.core.gl.GlFramebuffer;
import me.cortex.zenith.client.core.gl.GlTexture;
import me.cortex.zenith.client.core.gl.shader.Shader;
import me.cortex.zenith.client.core.gl.shader.ShaderType;
import org.lwjgl.opengl.GL11C;

import static org.lwjgl.opengl.ARBFramebufferObject.*;
import static org.lwjgl.opengl.ARBShaderImageLoadStore.glBindImageTexture;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL13.*;
import static org.lwjgl.opengl.GL15C.GL_READ_WRITE;
import static org.lwjgl.opengl.GL20C.glStencilFuncSeparate;
import static org.lwjgl.opengl.GL44C.glBindImageTextures;
import static org.lwjgl.opengl.GL45C.glBlitNamedFramebuffer;
import static org.lwjgl.opengl.GL45C.glTextureBarrier;

public class PostProcessing {
    private final GlFramebuffer framebuffer;
    private int width;
    private int height;
    private GlTexture colour;
    private GlTexture depthStencil;

    private final Shader ssao = Shader.make()
            .add(ShaderType.COMPUTE, "zenith:lod/ssao/ssao.comp")
            .compile();

    private final FullscreenBlit emptyBlit = new FullscreenBlit("zenith:post/noop.frag");
    private final FullscreenBlit blitTexture = new FullscreenBlit("zenith:post/blit_texture_cutout.frag");

    public PostProcessing() {
        this.framebuffer = new GlFramebuffer();
    }

    public void setSize(int width, int height) {
        if (this.width != width || this.height != height) {
            this.width = width;
            this.height = height;
            if (this.colour != null) {
                this.colour.free();
                this.depthStencil.free();
            }

            this.colour = new GlTexture().store(GL_RGBA8, 1, width, height);
            this.depthStencil = new GlTexture().store(GL_DEPTH24_STENCIL8, 1, width, height);

            this.framebuffer.bind(GL_COLOR_ATTACHMENT0, this.colour);
            this.framebuffer.bind(GL_DEPTH_STENCIL_ATTACHMENT, this.depthStencil);
            this.framebuffer.verify();
        }
    }



    public void shutdown() {
        this.framebuffer.free();
        if (this.colour != null) this.colour.free();
        if (this.depthStencil != null) this.depthStencil.free();
        this.ssao.free();
        this.emptyBlit.delete();
        this.blitTexture.delete();
    }

    public void setup(int width, int height, int sourceFB) {
        this.setSize(width, height);
        glBindFramebuffer(GL_FRAMEBUFFER, this.framebuffer.id);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
        glBlitNamedFramebuffer(sourceFB, this.framebuffer.id, 0,0, width, height, 0,0, width, height, GL_DEPTH_BUFFER_BIT, GL_NEAREST);

        //TODO: need to blit a fullscreen quad to generate a stencil mask of where the vanilla terrain is/isnt
        // then when rastering zenith terrain, only render to non masked areas
        //Hell once the stencil mask is computed, could clear the depth buffer and use a different near/far plane


        //Create a stencil mask of terrain generated by minecraft
        glEnable(GL_STENCIL_TEST);
        glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
        glStencilFunc(GL_ALWAYS, 1, 0xFF);
        glStencilMask(0xFF);

        glEnable(GL_DEPTH_TEST);
        glDepthMask(false);
        glColorMask(false,false,false,false);
        this.emptyBlit.blit();
        glColorMask(true,true,true,true);
        glDepthMask(true);
        glDisable(GL_DEPTH_TEST);

        //Clear the depth buffer we copied cause else it will interfear with results (not really i think idk)
        glClear(GL_DEPTH_BUFFER_BIT);


        //Make zenith terrain render only where there isnt mc terrain
        glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
        glStencilFunc(GL_EQUAL, 1, 0xFF);


        //glDisable(GL_STENCIL_TEST);


        //TODO: need to figure out how to do translucency cause doing it normally will cause water to have double translucency (i think)
    }

    //Computes ssao on the current framebuffer data and updates it
    // this means that translucency wont be effected etc
    public void computeSSAO() {

        //this.ssao.bind();
        //glActiveTexture(GL_TEXTURE1);
        //glBindTexture(GL_TEXTURE_2D, this.depthStencil.id);
        //glBindImageTexture(0, this.colour.id, 0, false,0, GL_READ_WRITE, GL_RGBA8);
        ////glDispatchCompute(this.width/32, this.height/32, 1);
        //glTextureBarrier();
        //glActiveTexture(GL_TEXTURE0);
        //glBindTexture(GL_TEXTURE_2D, this.colour.id);
        //glDrawArrays(GL11C.GL_TRIANGLES, 0, 3);
    }


    //Executes the post processing and emits to whatever framebuffer is currently bound via a blit
    public void renderPost(int outputFB) {
        glDisable(GL_STENCIL_TEST);



        glBindFramebuffer(GL_FRAMEBUFFER, outputFB);

        //This will need to be replaced with a blit shader to raster with respect to the stencil
        //glBlitNamedFramebuffer(this.framebuffer.id, outputFB, 0,0, this.width, this.height, 0,0, this.width, this.height, GL_COLOR_BUFFER_BIT, GL_NEAREST);



        int oldActiveTexture = glGetInteger(GL_ACTIVE_TEXTURE);
        glActiveTexture(GL_TEXTURE0);
        int oldBoundTexture = glGetInteger(GL_TEXTURE_BINDING_2D);
        glBindTexture(GL_TEXTURE_2D, this.colour.id);
        glEnable(GL_DEPTH_TEST);
        glDepthMask(false);
        this.blitTexture.blit();
        glDisable(GL_DEPTH_TEST);
        glDepthMask(true);
        glBindTexture(GL_TEXTURE_2D, oldBoundTexture);
        glActiveTexture(oldActiveTexture);
    }
}
